// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/event-graph-walker/rle"

import {
  "moonbitlang/core/quickcheck/splitmix",
}

// Values

// Errors
pub(all) suberror RleError {
  EmptyElement
  IndexOutOfBounds(index~ : Int, len~ : Int)
}
pub impl Show for RleError

// Types and methods
pub(all) struct BenchRun {
  len : Int
}
pub impl HasLength for BenchRun
pub impl Eq for BenchRun
pub impl Show for BenchRun

pub(all) struct PrefixSums {
  atoms : Array[Int]
  content : Array[Int]
}
pub fn PrefixSums::atom_at(Self, Int) -> Int?
pub fn PrefixSums::atom_before(Self, Int) -> Int
pub fn PrefixSums::content_len(Self) -> Int
pub fn PrefixSums::count(Self) -> Int
pub fn PrefixSums::len(Self) -> Int
pub fn PrefixSums::new() -> Self
pub impl Eq for PrefixSums
pub impl Show for PrefixSums
pub impl @moonbitlang/core/quickcheck.Arbitrary for PrefixSums
pub impl @moonbitlang/quickcheck.Shrink for PrefixSums

pub struct Rle[T] {
  runs : Runs[T]
  mut prefix : PrefixSums?
}
pub fn[T : Mergeable + HasLength] Rle::append(Self[T], T) -> Result[Unit, RleError]
pub fn[T] Rle::clear(Self[T]) -> Unit
pub fn[T : Mergeable + HasLength] Rle::concat(Self[T], Self[T]) -> Self[T]
pub fn[T : HasLength] Rle::content_len(Self[T]) -> Int
pub fn[T] Rle::count(Self[T]) -> Int
pub fn[T] Rle::cursor(Self[T]) -> RleCursor[T]
pub fn[T : Mergeable + HasLength] Rle::extend(Self[T], Self[T]) -> Unit
pub fn[T : HasLength] Rle::find(Self[T], Int) -> RunPos?
pub fn[T : Mergeable + HasLength] Rle::from_array(Array[T]) -> Self[T]
pub fn[T] Rle::from_runs(Runs[T]) -> Self[T]
pub fn Rle::from_string(String) -> Self[String]
pub fn[T] Rle::get(Self[T], Int) -> T?
pub fn[T] Rle::is_empty(Self[T]) -> Bool
pub fn[T] Rle::iter(Self[T]) -> Iter[T]
pub fn Rle::iter_chars(Self[String]) -> Iter[Char]
pub fn[T : HasLength] Rle::len(Self[T]) -> Int
pub fn[T] Rle::new() -> Self[T]
pub fn[T : HasLength] Rle::range(Self[T], start~ : Int, end~ : Int) -> Result[Iter[Slice[T]], RleError]
pub fn[T : HasLength] Rle::range_clamped(Self[T], start~ : Int, end~ : Int) -> Iter[Slice[T]]
pub fn[T : Sliceable + HasLength + Mergeable] Rle::split(Self[T], Int) -> Result[(Self[T], Self[T]), RleError]
pub fn[T] Rle::to_runs(Self[T]) -> Runs[T]
pub fn Rle::to_string(Self[String]) -> String
pub impl[T : Eq] Eq for Rle[T]
pub impl[T : Show] Show for Rle[T]
pub impl @moonbitlang/core/quickcheck.Arbitrary for Rle[String]
pub impl @moonbitlang/quickcheck.Shrink for Rle[String]

pub struct RleCursor[T] {
  rle : Rle[T]
  mut run_index : Int
  mut offset_in_run : Int
  mut global_offset : Int
}
pub fn[T : HasLength] RleCursor::advance(Self[T], Int) -> Bool
pub fn[T : HasLength] RleCursor::at_end(Self[T]) -> Bool
pub fn[T] RleCursor::current(Self[T]) -> (T, Int)?
pub fn[T] RleCursor::current_item(Self[T]) -> T?
pub fn[T : HasLength] RleCursor::iter_forward(Self[T]) -> Iter[(T, Int, Int)]
pub fn[T : HasLength] RleCursor::next(Self[T]) -> T?
pub fn[T] RleCursor::position(Self[T]) -> Int
pub fn[T : HasLength] RleCursor::prev(Self[T]) -> T?
pub fn[T : HasLength] RleCursor::retreat(Self[T], Int) -> Bool
pub fn[T : HasLength] RleCursor::seek(Self[T], Int) -> Bool
pub fn[T : HasLength] RleCursor::seek_end(Self[T]) -> Unit
pub fn[T] RleCursor::seek_start(Self[T]) -> Unit
pub impl[T : Eq] Eq for RleCursor[T]
pub impl[T : Show] Show for RleCursor[T]

pub(all) struct RunPos {
  run : Int
  offset : Int
}
pub impl Eq for RunPos
pub impl Show for RunPos
pub impl @moonbitlang/core/quickcheck.Arbitrary for RunPos
pub impl @moonbitlang/quickcheck.Shrink for RunPos

pub struct Runs[T](Array[T])
pub fn[T : Mergeable + HasLength] Runs::append(Self[T], T) -> Result[Unit, RleError]
pub fn[T] Runs::clear(Self[T]) -> Unit
pub fn[T : Mergeable + HasLength] Runs::concat(Self[T], Self[T]) -> Self[T]
pub fn[T : HasLength] Runs::content_len(Self[T]) -> Int
pub fn[T] Runs::count(Self[T]) -> Int
pub fn[T : Mergeable + HasLength] Runs::extend(Self[T], Self[T]) -> Unit
pub fn[T : HasLength] Runs::find(Self[T], Int) -> RunPos?
pub fn[T] Runs::find_fast(Self[T], PrefixSums, Int) -> RunPos?
pub fn[T : Mergeable + HasLength] Runs::from_array(Array[T]) -> Self[T]
pub fn Runs::from_string(String) -> Self[String]
pub fn[T] Runs::get(Self[T], Int) -> T?
#deprecated
pub fn[T] Runs::inner(Self[T]) -> Array[T]
pub fn[T] Runs::is_empty(Self[T]) -> Bool
pub fn[T] Runs::iter(Self[T]) -> Iter[T]
pub fn Runs::iter_chars(Self[String]) -> Iter[Char]
pub fn[T : HasLength] Runs::len(Self[T]) -> Int
pub fn[T] Runs::new() -> Self[T]
pub fn[T : HasLength] Runs::prefix_sums(Self[T]) -> PrefixSums
pub fn[T : HasLength] Runs::range(Self[T], start~ : Int, end~ : Int) -> Result[Iter[Slice[T]], RleError]
pub fn[T : HasLength] Runs::range_clamped(Self[T], start~ : Int, end~ : Int) -> Iter[Slice[T]]
pub fn[T : Sliceable + HasLength + Mergeable] Runs::split(Self[T], Int) -> Result[(Self[T], Self[T]), RleError]
pub fn[T] Runs::to_array(Self[T]) -> Array[T]
pub fn Runs::to_string(Self[String]) -> String
pub impl[T : Eq] Eq for Runs[T]
pub impl[T : Show] Show for Runs[T]
pub impl @moonbitlang/core/quickcheck.Arbitrary for Runs[String]
pub impl @moonbitlang/quickcheck.Shrink for Runs[String]

pub(all) struct Slice[T] {
  value : T
  start : Int
  end : Int
}
pub fn[T : Sliceable] Slice::to_inner(Self[T]) -> T
pub impl[T : Eq] Eq for Slice[T]
pub impl[T : Show] Show for Slice[T]
pub impl @moonbitlang/core/quickcheck.Arbitrary for Slice[String]
pub impl @moonbitlang/quickcheck.Shrink for Slice[String]

// Type aliases

// Traits
pub(open) trait HasLength {
  atom_len(Self) -> Int
  content_len(Self) -> Int
}
pub impl HasLength for String

pub(open) trait Mergeable {
  can_merge(Self, Self) -> Bool
  merge(Self, Self) -> Self
}
pub impl Mergeable for String

pub(open) trait Sliceable {
  slice(Self, start~ : Int, end~ : Int) -> Self
}
pub impl Sliceable for String

