// Generated using `moon info`, DON'T EDIT IT
package "dowdiness/event-graph-walker/rle"

import {
  "moonbitlang/core/builtin",
  "moonbitlang/core/quickcheck/splitmix",
}

// Values

// Errors
pub(all) suberror InternalError {
  EmptyElement
  InvalidState(detail~ : String)
}
pub impl Show for InternalError

pub(all) suberror RleError {
  PositionOutOfBounds(position~ : Int, length~ : Int)
  InvalidRange(start~ : Int, end~ : Int, length~ : Int, reason~ : RangeIssue)
  Internal(InternalError)
}
pub fn RleError::message(Self) -> ErrorMessage
pub impl Show for RleError

// Types and methods
pub(all) struct BenchRun {
  len : Int
}
pub impl HasCausalLength for BenchRun
pub impl HasLength for BenchRun
pub impl Eq for BenchRun
pub impl Show for BenchRun

pub struct ErrorMessage {
  // private fields
}
pub impl Show for ErrorMessage

pub(all) struct PrefixSums {
  atoms : Array[Int]
  content : Array[Int]
}
pub fn PrefixSums::atom_at(Self, Int) -> Int?
pub fn PrefixSums::atom_before(Self, Int) -> Int
pub fn PrefixSums::count(Self) -> Int
pub fn PrefixSums::len(Self) -> Int
pub fn PrefixSums::new() -> Self
pub fn PrefixSums::visible_len(Self) -> Int
pub impl Eq for PrefixSums
pub impl Show for PrefixSums
pub impl @moonbitlang/core/quickcheck.Arbitrary for PrefixSums
pub impl @moonbitlang/quickcheck.Shrink for PrefixSums

pub enum RangeIssue {
  NegativeStart
  NegativeEnd
  StartAfterEnd
  ExceedsLength
}
pub impl Eq for RangeIssue
pub impl Show for RangeIssue

pub struct Rle[T] {
  runs : Runs[T]
  mut prefix : PrefixSums?
  mut version : Int
}
pub fn[T : Mergeable + HasCausalLength] Rle::append(Self[T], T) -> Result[Unit, RleError]
pub fn[T] Rle::clear(Self[T]) -> Unit
pub fn[T : Mergeable + HasCausalLength] Rle::concat(Self[T], Self[T]) -> Self[T]
pub fn[T] Rle::count(Self[T]) -> Int
pub fn[T] Rle::cursor(Self[T]) -> RleCursor[T]
pub fn[T : Mergeable + HasCausalLength] Rle::extend(Self[T], Self[T]) -> Unit
pub fn[T : HasCausalLength] Rle::find(Self[T], Int) -> RunPos?
pub fn[T : Mergeable + HasCausalLength] Rle::from_array(Array[T]) -> Self[T]
pub fn[T] Rle::from_runs(Runs[T]) -> Self[T]
pub fn Rle::from_string(String) -> Self[String]
pub fn[T] Rle::get(Self[T], Int) -> T?
pub fn[T] Rle::get_version(Self[T]) -> Int
pub fn[T] Rle::is_empty(Self[T]) -> Bool
pub fn[T] Rle::iter(Self[T]) -> Iter[T]
pub fn Rle::iter_chars(Self[String]) -> Iter[Char]
pub fn[T : HasCausalLength] Rle::len(Self[T]) -> Int
pub fn[T] Rle::new() -> Self[T]
pub fn[T : HasCausalLength] Rle::range(Self[T], start~ : Int, end~ : Int) -> Result[Iter[Slice[T]], RleError]
pub fn[T : HasCausalLength] Rle::range_clamped(Self[T], start~ : Int, end~ : Int) -> Iter[Slice[T]]
pub fn[T : Sliceable + HasCausalLength + Mergeable] Rle::split(Self[T], Int) -> Result[(Self[T], Self[T]), RleError]
pub fn[T] Rle::to_runs(Self[T]) -> Runs[T]
pub fn Rle::to_string(Self[String]) -> String
pub fn[T : HasCausalLength] Rle::visible_len(Self[T]) -> Int
pub impl[T : Eq] Eq for Rle[T]
pub impl[T : Show] Show for Rle[T]
pub impl @moonbitlang/core/quickcheck.Arbitrary for Rle[String]
pub impl @moonbitlang/quickcheck.Shrink for Rle[String]

pub struct RleCursor[T] {
  rle : Rle[T]
  version : Int
  mut run_index : Int
  mut offset_in_run : Int
  mut global_offset : Int
}
pub fn[T : HasCausalLength] RleCursor::advance(Self[T], Int) -> Bool
pub fn[T : HasCausalLength] RleCursor::at_end(Self[T]) -> Bool
pub fn[T] RleCursor::current(Self[T]) -> (T, Int)?
pub fn[T] RleCursor::current_item(Self[T]) -> T?
pub fn[T] RleCursor::is_stale(Self[T]) -> Bool
pub fn[T : HasCausalLength] RleCursor::iter_forward(Self[T]) -> Iter[(T, Int, Int)]
pub fn[T : HasCausalLength] RleCursor::next(Self[T]) -> T?
pub fn[T] RleCursor::position(Self[T]) -> Int?
pub fn[T : HasCausalLength] RleCursor::prev(Self[T]) -> T?
pub fn[T : HasCausalLength] RleCursor::retreat(Self[T], Int) -> Bool
pub fn[T : HasCausalLength] RleCursor::seek(Self[T], Int) -> Bool
pub fn[T : HasCausalLength] RleCursor::seek_end(Self[T]) -> Unit
pub fn[T] RleCursor::seek_start(Self[T]) -> Unit
pub impl[T : Eq] Eq for RleCursor[T]
pub impl[T : Show] Show for RleCursor[T]

pub(all) struct RunPos {
  run : Int
  offset : Int
}
pub impl Eq for RunPos
pub impl Show for RunPos
pub impl @moonbitlang/core/quickcheck.Arbitrary for RunPos
pub impl @moonbitlang/quickcheck.Shrink for RunPos

pub struct Runs[T](Array[T])
pub fn[T : Mergeable + HasCausalLength] Runs::append(Self[T], T) -> Result[Unit, RleError]
pub fn[T] Runs::clear(Self[T]) -> Unit
pub fn[T : Mergeable + HasCausalLength] Runs::concat(Self[T], Self[T]) -> Self[T]
pub fn[T] Runs::count(Self[T]) -> Int
pub fn[T : Mergeable + HasCausalLength] Runs::extend(Self[T], Self[T]) -> Unit
pub fn[T : HasCausalLength] Runs::find(Self[T], Int) -> RunPos?
pub fn[T] Runs::find_fast(Self[T], PrefixSums, Int) -> RunPos?
pub fn[T : Mergeable + HasCausalLength] Runs::from_array(Array[T]) -> Self[T]
pub fn[T : Mergeable + HasCausalLength] Runs::from_array_batch(Array[T]) -> Self[T]
pub fn Runs::from_string(String) -> Self[String]
pub fn[T] Runs::get(Self[T], Int) -> T?
#deprecated
pub fn[T] Runs::inner(Self[T]) -> Array[T]
pub fn[T] Runs::is_empty(Self[T]) -> Bool
pub fn[T] Runs::iter(Self[T]) -> Iter[T]
pub fn Runs::iter_chars(Self[String]) -> Iter[Char]
pub fn[T : HasCausalLength] Runs::len(Self[T]) -> Int
pub fn[T] Runs::new() -> Self[T]
pub fn[T : HasCausalLength] Runs::prefix_sums(Self[T]) -> PrefixSums
pub fn[T : HasCausalLength] Runs::range(Self[T], start~ : Int, end~ : Int) -> Result[Iter[Slice[T]], RleError]
pub fn[T : HasCausalLength] Runs::range_clamped(Self[T], start~ : Int, end~ : Int) -> Iter[Slice[T]]
pub fn[T : Sliceable + HasCausalLength + Mergeable] Runs::split(Self[T], Int) -> Result[(Self[T], Self[T]), RleError]
pub fn[T] Runs::to_array(Self[T]) -> Array[T]
pub fn Runs::to_string(Self[String]) -> String
pub fn[T : HasCausalLength] Runs::visible_len(Self[T]) -> Int
pub impl[T : Eq] Eq for Runs[T]
pub impl[T : Show] Show for Runs[T]
pub impl @moonbitlang/core/quickcheck.Arbitrary for Runs[String]
pub impl @moonbitlang/quickcheck.Shrink for Runs[String]

pub struct Slice[T] {
  value : T
  start : Int
  end : Int
}
pub fn[T : Sliceable] Slice::to_inner(Self[T]) -> T
pub impl[T : Eq] Eq for Slice[T]
pub impl[T : Show] Show for Slice[T]
pub impl @moonbitlang/core/quickcheck.Arbitrary for Slice[String]
pub impl @moonbitlang/quickcheck.Shrink for Slice[String]

// Type aliases
pub using @builtin {type Option as MayStale}

// Traits
pub(open) trait HasCausalLength : HasLength {
  causal_len(Self) -> Int = _
  visible_len(Self) -> Int
}
pub impl HasCausalLength for String

pub(open) trait HasLength {
  length(Self) -> Int
}
pub impl HasLength for String

pub(open) trait Mergeable {
  can_merge(Self, Self) -> Bool
  merge(Self, Self) -> Self
}
pub impl Mergeable for String

pub(open) trait Sliceable {
  slice(Self, start~ : Int, end~ : Int) -> Self
}
pub impl Sliceable for String

